{-| @pipes-parse@ handles end-of-input and pushback by storing a 'Producer' in
    a 'StateT' layer.  'input' provides a 'Producer' that streams from the
    underlying 'Producer'.  The difference is that any unused input from the
    stored 'Producer' is not lost, and is instead saved for later use.

    For example, you can request a single element at a time from the stored
    'Producer' using 'Pipes.Prelude.head' from @Pipes.Prelude@.  The following
    code is not idiomatic, but still demonstrates the underlying principle:

> import Control.Monad (replicateM_)
> import Pipes
> import Pipes.Parse
> import qualified Pipes.Prelude as P
> 
> parser1 :: (Show a) => StateT (Producer a IO r) IO ()
> parser1 = replicateM_ 4 $ do
>     x <- P.head input
>     liftIO $ print x

    Each use of 'Pipes.Prelude.head' on 'input' advances the underlying
    'Producer' instead of restarting from the beginning:

>>>  evalStateT parser1 (each [1..3])
Just 1
Just 2
Just 3
Nothing

    Unlike most parsing libraries, @pipes-parse@ does not expose a \"pushback\"
    command to return unused input to the underlying stream.  Instead, you use
    'zoom' from @Control.Lens@ to segment the underlying 'Producer' and limit
    your sub-parser to exactly the subset of the input stream that you require.
    You specify the subset you are interested in using an isomorphism like
    'splits' or 'spans':

> -- A parser that prints all elements available to it
> printAll :: (Show a) => StateT (Producer a IO r) IO ()
> printAll = run $ for input (liftIO . print)
>
> parser2 :: StateT (Producer Int IO r) IO ()
> parser2 = do
>     -- Restrict the first sub-parser to elements less than 4
>     zoom (spans (< 4)) printAll
> 
>     liftIO $ putStrLn "Intermission"
>
>     -- Restrict the second sub-parser to the next three elements
>     zoom (splits 3) printAll

>>> evalStateT parser2 (each [1..])
1
2
3
Intermission
4
5
6

    There is no need to pushback unused elements.  When you 'zoom' in using an
    isomorphism like 'spans' or 'splits' they will simply forbid you from
    drawing more elements than you need.  In other words, the isomorphisms
    are responsible for handling the pushback, not the parser.
-}

module Pipes.Parse (
    -- * Input Stream
    input,

    -- * Isomorphisms
    spans,
    splits,

    -- * Re-exports
    -- $re-exports
    module Control.Lens,
    module Control.Monad.IO.Class,
    module Control.Monad.Trans.State
    ) where

import Control.Lens (Iso', zoom)
import qualified Control.Lens as L
import Control.Monad (join)
import Control.Monad.IO.Class (MonadIO(liftIO))
import Control.Monad.Trans.Class (lift)
import Control.Monad.Trans.State (StateT, runStateT, evalStateT, execStateT)
import qualified Control.Monad.Trans.State as S
import Pipes (Producer, yield, next)
import Pipes.Core (Producer')

_draw :: (Monad m) => StateT (Producer a m r) m (Maybe a)
_draw = do
    p <- S.get
    x <- lift (next p)
    case x of
        Left   _      -> return Nothing
        Right (e, p') -> do
            S.put p'
            return (Just e)

{-| Stream from the stored 'Producer'

    Streaming from 'input' differs from streaming directly from the underlying
    'Producer' because any unused input is saved for later.
-}
input :: (Monad m) => Producer' a (StateT (Producer a m r) m) ()
input = loop
  where
    loop = do
        me <- lift _draw
        case me of
            Nothing -> return ()
            Just e  -> do
                yield e
                loop

_span
    :: (Monad m)
    => (a -> Bool) -> Producer a m r -> Producer a m (Producer a m r)
_span predicate = loop
  where
    loop p = do
        x <- lift (next p)
        case x of
            Left   r      -> return (return r)
            Right (e, p') ->
                if (predicate e)
                then do
                    yield e
                    loop p'
                else return (yield e >> p')

{-| Isomorphism between a 'Producer' and the prefix \/ suffix generated by
    splitting the 'Producer' in a manner analogous to 'span'

    Use this isomorphism to limit a 'Producer' to the prefix of all elements
    that satisfy a given predicate.
-}
spans
    :: (Monad m)
    => (a -> Bool) -> Iso' (Producer a m r) (Producer a m (Producer a m r))
spans predicate = L.iso (_span predicate) join

_splitAt :: (Monad m) => Int -> Producer a m r -> Producer a m (Producer a m r)
_splitAt n p =
    if (n <= 0)
    then return p
    else do
        x <- lift $ next p
        case x of
            Left   r      -> return (return r)
            Right (e, p') -> do
                yield e
                _splitAt (n - 1) p'


{-| Isomorphism between a 'Producer' and the prefix \/ suffix generated by
    splitting the 'Producer' in a manner analogous to 'splitAt'

    Use this isomorphism to limit a 'Producer' to a fixed number of elements.
-}
splits
    :: (Monad m) => Int -> Iso' (Producer a m r) (Producer a m (Producer a m r))
splits n = L.iso (_splitAt n) join

{- $re-exports
    @Control.Lens@ re-exports 'zoom' and 'Iso''.

    @Control.Monad.Trans.State@ re-exports 'StateT' (the type), 'runStateT',
    'evalStateT', and 'execStateT'.

    @Control.Monad.IO.Class@ re-exports 'MonadIO'.
-}
